# Cursor Rules for Browser Automation Service

This file provides development guidelines and best practices for working with the Browser Automation Service codebase.

## Code Organization Philosophy

### Core Principle: Separation of Concerns

We maintain a **clear distinction** between:
1. **Browser-Use Core Code** (`browser_use/` directory) - Original Browser-Use library (embedded source)
2. **Our Extensions** (`navigator/` directory) - Our custom code for Browser Automation Service

This separation enables:
- **Easy Browser-Use Upgrades**: Can upgrade Browser-Use code independently
- **Clear Boundaries**: Know what's ours vs what's upstream
- **Maintainability**: Easier to track changes and contributions
- **Performance**: Direct source access while maintaining upgrade path

---

## Code Separation Guidelines

### 1. Directory Structure

```
/
├── browser_use/          # Browser-Use core library (upstream code)
│   ├── browser/
│   ├── agent/
│   ├── tools/
│   └── ...
│
├── navigator/            # Our extensions (custom code)
│   ├── action/           # Action command system
│   ├── session/          # Session management
│   ├── streaming/        # LiveKit streaming
│   ├── server/           # MCP and WebSocket servers
│   ├── knowledge/        # Knowledge retrieval flow
│   ├── presentation/     # Presentation flow management
│   └── ...
│
└── dev-docs/             # Our documentation (3 canonical guides only)
    ├── QUICK_START.md            # Development & server setup
    ├── BROWSER_AUTOMATION_AGENT.md  # Agent integration reference
    └── KNOWLEDGE_EXTRACTION.md     # Knowledge pipeline reference
```

---

## Documentation Policy

**CRITICAL**: We maintain exactly **3 comprehensive documentation files**:

1. **`dev-docs/QUICK_START.md`** - Development setup and server operations
2. **`dev-docs/BROWSER_AUTOMATION_AGENT.md`** - Agent integration, MCP tools, actions
3. **`dev-docs/KNOWLEDGE_EXTRACTION.md`** - Knowledge extraction pipeline

### Documentation Rules

**❌ NEVER create new documentation files** unless explicitly requested by the user
**❌ NEVER create README files** in subdirectories (examples, tests, etc.)
**❌ NEVER create migration guides, quickstart files, or duplicate docs
**✅ DO update the 3 canonical guides when making significant changes
**✅ DO focus on schemas, contracts, and architectural details (not code examples)
**✅ DO keep documentation concise and reference-focused

When user makes changes:
- Update relevant sections in the 3 guides
- Do NOT create new documentation files
- Do NOT add verbose code examples (schemas/contracts only)

---

### 2. Import Patterns

**✅ DO: Import from Browser-Use**
```python
# In navigator/ files, import from browser_use
from browser_use import BrowserSession
from browser_use.browser.profile import BrowserProfile
from browser_use.browser.events import NavigateToUrlEvent
from browser_use.tools.service import Tools
```

**❌ DON'T: Modify Browser-Use imports directly in our code**
```python
# Don't do this - keep browser_use/ code unchanged
from browser_use.browser.session import BrowserSession
# Then modify BrowserSession in place
```

### 3. Extending vs Modifying Browser-Use

**✅ DO: Extend Browser-Use Components**
- Create wrapper classes in `navigator/` that use Browser-Use components
- Add new functionality in `navigator/` that imports and uses Browser-Use
- Example: `ActionDispatcher` wraps `BrowserSession` and adds action command handling

**✅ DO: Use Browser-Use APIs**
- Use public APIs (BrowserSession, BrowserProfile, Tools, etc.)
- Follow Browser-Use patterns and conventions
- Leverage event-driven architecture

**⚠️ AVOID: Direct Modifications to Browser-Use**
- Avoid modifying `browser_use/` code directly unless absolutely necessary
- If modification is needed, document it clearly and consider upstream contribution
- Prefer extending/wrapping over modifying

**❌ DON'T: Mix Our Code into Browser-Use**
- Don't put our code in `browser_use/` directory
- Don't modify Browser-Use core files without clear justification
- Keep `browser_use/` as clean upstream code

---

## Browser-Use Upgrade Strategy

### When Upgrading Browser-Use

1. **Identify Upgrade Source**
   - Check Browser-Use repository for new versions
   - Review changelog for breaking changes
   - Identify new features/APIs we can use

2. **Prepare for Upgrade**
   - **Backup Current State**: Commit all changes to `navigator/` and `dev-docs/`
   - **Check Dependencies**: Review `pyproject.toml` for version constraints
   - **Review Breaking Changes**: Check Browser-Use migration guides
   - **Document Custom Modifications**: List any changes made to `browser_use/` code

3. **Upgrade Process**
   - **Option A: Git Merge/Rebase** (if forked from Browser-Use)
     ```bash
     git remote add upstream https://github.com/browser-use/browser-use.git
     git fetch upstream
     git merge upstream/main  # or rebase
     ```
   
   - **Option B: Replace browser_use/ Directory**
     ```bash
     # Backup current browser_use/
     cp -r browser_use/ browser_use.backup/
     
     # Replace with new version (from PyPI source or git clone)
     # Then restore any custom modifications if needed
     ```

4. **Post-Upgrade Validation**
   - Run tests: `uv run pytest tests/ci/`
   - Test navigator functionality: `uv run python navigator/tests/validate_mvp.py`
   - Check imports: Verify all `navigator/` imports from `browser_use/` still work
   - Review breaking changes: Update `navigator/` code if Browser-Use APIs changed
   - Verify no regressions: Test all major flows (presentation, knowledge retrieval)

5. **Document Changes**
   - Update relevant sections in the 3 canonical documentation guides
   - Document any required changes to `navigator/` code
   - Update version in `pyproject.toml` to reflect new Browser-Use version
   - Do NOT create new documentation files (migration guides, quickstarts, etc.)

### Tracking Browser-Use Modifications

If we **must** modify Browser-Use code:

1. **Document in CHANGELOG.md**
   ```markdown
   ## Browser-Use Modifications
   
   ### browser_use/browser/session.py
   - Modified: Line 123 - Added custom timeout handling
   - Reason: Required for 6-hour session timeout
   - Impact: Breaks upgrade compatibility
   ```

2. **Use Git Branches/Patches**
   - Create branch: `browser-use-modified`
   - Keep modifications minimal and documented
   - Consider upstream contribution for generic changes

3. **Version Pinning**
   - Pin Browser-Use version in `pyproject.toml` if modifications break upgrade path
   - Document why upgrade is blocked

### Detailed Upgrade Process

#### Step-by-Step Upgrade Guide

**1. Pre-Upgrade Checklist**
```bash
# Ensure clean working directory
git status  # Should be clean or all changes committed

# Create backup branch
git checkout -b backup-before-browser-use-upgrade
git push origin backup-before-browser-use-upgrade

# Document current version
echo "Current Browser-Use version: $(grep '^version =' pyproject.toml)"
```

**2. Identify Target Version**
- Check Browser-Use releases: https://github.com/browser-use/browser-use/releases
- Review changelog for breaking changes
- Identify new features that could benefit our codebase

**3. Choose Upgrade Method**

**Method A: Git Merge (Recommended if forked from Browser-Use)**
```bash
# Add upstream remote if not already added
git remote add upstream https://github.com/browser-use/browser-use.git || true
git fetch upstream

# Create upgrade branch
git checkout -b browser-use-upgrade-v0.12.0

# Merge upstream changes
git merge upstream/main  # or specific version tag

# Resolve conflicts if any
# Test thoroughly before merging to main
```

**Method B: Directory Replacement (If not forked)**
```bash
# Create upgrade branch
git checkout -b browser-use-upgrade-v0.12.0

# Backup current browser_use/
cp -r browser_use/ browser_use.backup/

# Clone new version
git clone --depth 1 --branch v0.12.0 https://github.com/browser-use/browser-use.git browser_use_new

# Replace directory
rm -rf browser_use/
mv browser_use_new/browser_use/ browser_use/

# Restore any custom modifications from backup
# (Compare and merge manually)
```

**4. Post-Upgrade Steps**
```bash
# Update dependencies
uv sync

# Run tests
uv run pytest tests/ci/ -v

# Check for import errors
uv run python -c "from navigator.server.mcp import BrowserAutomationMCPServer; print('✅ Imports OK')"

# Run validation
uv run python navigator/tests/validate_mvp.py

# Check for type errors
uv run pyright navigator/

# Update version in pyproject.toml
# Update any breaking changes in navigator/ code
```

**5. Document Upgrade**
- Create `dev-docs/UPGRADE_NOTES_v0.12.0.md` with:
  - Breaking changes encountered
  - Code changes required in `navigator/`
  - New features available
  - Performance improvements
  - Known issues

**6. Testing Checklist**
- [ ] All existing tests pass
- [ ] Navigator imports work correctly
- [ ] Presentation flow works
- [ ] Knowledge retrieval flow works
- [ ] MCP server starts without errors
- [ ] LiveKit streaming works
- [ ] No regressions in functionality

---

## Development Best Practices

### 1. Code Style

Follow Browser-Use conventions (as defined in `CLAUDE.md`):

- **Indentation**: Use **tabs** (not spaces) for Python code
- **Type Hints**: Use modern Python 3.12+ typing (`str | None` not `Optional[str]`)
- **Async**: Use `async`/`await` throughout
- **Pydantic**: Use Pydantic v2 models for data structures
- **Logging**: Use `logger = logging.getLogger(__name__)` pattern

### 2. File Organization

**Our Code (`navigator/`):**
- Keep related functionality together
- Use descriptive file names
- Follow single-responsibility principle
- Document public APIs
- Organize by feature area (action, session, streaming, knowledge, etc.)

**Browser-Use Code (`browser_use/`):**
- Don't modify unless necessary
- If modifying, document why
- Keep modifications minimal

### 3. Testing

- **Our Tests**: Put tests for `navigator/` code in `tests/ci/` with prefix `test_navigator_*`
- **Integration Tests**: Test `navigator/` + `browser_use/` integration
- **Validation Scripts**: Use `navigator/tests/validate_mvp.py` for validation

### 4. Documentation

**CRITICAL**: We maintain exactly 3 canonical documentation files:
- **`dev-docs/QUICK_START.md`**: Development setup and server operations
- **`dev-docs/BROWSER_AUTOMATION_AGENT.md`**: Agent integration, MCP tools, browser actions
- **`dev-docs/KNOWLEDGE_EXTRACTION.md`**: Knowledge extraction pipeline, Temporal workflows

**Never create additional documentation files.** Update these 3 guides only.

### 5. Dependencies

- **Browser-Use Dependencies**: Manage in `pyproject.toml` (inherited)
- **Our Dependencies**: Add to `pyproject.toml` under `[project.dependencies]`
- **Version Management**: Use `uv` for dependency management (not `pip`)

### 6. Import Organization

**In `navigator/` files:**
```python
# Standard library
import asyncio
import logging
from typing import Any

# Third-party
from browser_use import BrowserSession  # Browser-Use imports
from browser_use.browser.profile import BrowserProfile

# Our code
from navigator.action.command import ActionCommand, ActionType
from navigator.action.dispatcher import ActionDispatcher
```

### 7. Error Handling

- Use Browser-Use exception types when appropriate
- Create custom exceptions in `navigator/` if needed
- Document error scenarios

### 8. Logging

- Use structured logging with levels (DEBUG, INFO, WARNING, ERROR)
- Log at appropriate levels:
  - DEBUG: Detailed execution flow
  - INFO: Important state changes
  - WARNING: Recoverable issues
  - ERROR: Failures requiring attention

---

## Common Patterns

### Pattern 1: Wrapper Class

```python
# navigator/session/manager.py
from browser_use import BrowserSession
from browser_use.browser.profile import BrowserProfile

class BrowserSessionManager:
    """Wrapper around BrowserSession with our custom logic."""
    
    def __init__(self):
        self.sessions: dict[str, BrowserSession] = {}
    
    async def start_session(self, room_name: str, **kwargs):
        # Use BrowserSession, don't modify it
        browser_session = BrowserSession(**kwargs)
        await browser_session.start()
        self.sessions[room_name] = browser_session
```

### Pattern 2: Event Handler Extension

```python
# navigator/action/dispatcher.py
from browser_use import BrowserSession
from browser_use.browser.events import ClickElementEvent

class ActionDispatcher:
    """Dispatches actions using Browser-Use events."""
    
    def __init__(self, browser_session: BrowserSession):
        self.browser_session = browser_session  # Use, don't modify
    
    async def execute_click(self, index: int):
        # Use Browser-Use events
        event = self.browser_session.event_bus.dispatch(
            ClickElementEvent(index=index)
        )
        await event
```

### Pattern 3: Service Composition

```python
# navigator/server/mcp.py
from browser_use import BrowserSession
from navigator.session.manager import BrowserSessionManager
from navigator.action.dispatcher import ActionDispatcher

class BrowserAutomationMCPServer:
    """Composes our services with Browser-Use."""
    
    def __init__(self):
        # Our services
        self.session_manager = BrowserSessionManager()
        # Uses BrowserSession internally
```

---

## Git Workflow

### Branching Strategy

- **main**: Stable code with working service
- **feature/***: New features in `navigator/`
- **browser-use-upgrade**: Browser-Use upgrades
- **browser-use-modified**: If we modify Browser-Use code

### Commit Messages

Follow conventional commits:
```
feat(navigator): Add presentation flow manager
fix(navigator): Fix action dispatcher timeout handling
docs(dev-docs): Update architecture documentation
upgrade(browser-use): Upgrade to Browser-Use v0.12.0
```

### Before Committing

1. ✅ Run tests: `uv run pytest tests/ci/`
2. ✅ Run validation: `uv run python navigator/tests/validate_mvp.py`
3. ✅ Check code style: `uv run ruff check --fix`
4. ✅ Check types: `uv run pyright`
5. ✅ Verify imports: All `navigator/` imports from `browser_use/` work
6. ✅ Review changes: No accidental modifications to `browser_use/`

---

## When to Modify Browser-Use vs Extend

### ✅ Extend (Preferred)

- Adding new functionality
- Customizing behavior
- Adding new actions/events
- Integrating with external services (LiveKit, MCP)

### ⚠️ Modify (Only When Necessary)

- Performance optimizations specific to our use case
- Bug fixes that can't wait for upstream
- Critical features not available upstream

### ❌ Don't Modify

- Standard functionality that works fine
- Code that's actively maintained upstream
- Features that could be contributed upstream

---

## Quick Reference

### Common Commands

```bash
# Run tests
uv run pytest tests/ci/

# Validate navigator functionality
uv run python navigator/tests/validate_mvp.py

# Check code style
uv run ruff check --fix
uv run ruff format

# Check types
uv run pyright

# Start server
uv run python navigator/start_server.py

# Install dependencies
uv sync
```

### Important Files

- **Our Code**: `navigator/**/*.py`
- **Browser-Use Code**: `browser_use/**/*.py`
- **Our Docs**: `dev-docs/*.md`
- **Dependencies**: `pyproject.toml`
- **Configuration**: `.env` (not committed)

### Key Principles

1. ✅ Keep `navigator/` and `browser_use/` separate
2. ✅ Extend, don't modify Browser-Use when possible
3. ✅ Document Browser-Use modifications if needed
4. ✅ Test after Browser-Use upgrades
5. ✅ Use Browser-Use APIs, don't hack internals
6. ✅ Follow Browser-Use code style conventions
7. ✅ Keep upgrade path clear
8. ✅ Treat `browser_use/` as embedded source (not external dependency)

---

## Architecture Approach

### Current Setup: Embedded Source with Extension Boundaries

**What We're Doing:**
- **`browser_use/`**: Embedded source code of Browser-Use library (version 0.11.2)
- **`navigator/`**: Our extensions that import `browser_use` as a library
- **Import Pattern**: `navigator/` code imports from `browser_use` like: `from browser_use import BrowserSession`

**Why This Approach:**
- ✅ **Full Source Access**: Can debug and optimize Browser-Use internals directly
- ✅ **Clear Boundaries**: `navigator/` extends without modifying `browser_use/`
- ✅ **Performance**: No abstraction overhead, direct access to source
- ✅ **Flexibility**: Can modify `browser_use/` if needed (with documentation)
- ✅ **Upgrade Path**: Can upgrade `browser_use/` directory via git merge/replace

**Alternative Approaches Considered:**
- ❌ **External Library (PyPI)**: Would lose source access and debugging capability
- ❌ **Embed navigator into browser_use**: Would mix concerns and complicate upstream contributions

---

## Summary

**Core Philosophy**: 
- **Browser-Use** (`browser_use/`) = Embedded upstream library source (keep clean, upgradeable)
- **Our Extensions** (`navigator/`) = Our custom code (full control, our responsibility)

**Key Rule**: 
> Prefer extending Browser-Use in `navigator/` over modifying `browser_use/` directly. Only modify `browser_use/` when absolutely necessary, and document it clearly.

**Upgrade Path**: 
> Keep `browser_use/` code clean and upgradeable. When upgrading, validate all `navigator/` code still works with new Browser-Use version. Use git merge/replace strategy to upgrade the `browser_use/` directory.

---

*Last Updated: 2025*
*Version: 1.0.0*
