# Cursor Rules for Browser Automation Service

Development guidelines and best practices for the Browser Automation Service codebase.

---

## ðŸ“‹ Quick Reference: All Rules Summary

### ðŸš¨ CRITICAL RULES (Strictly Enforced)

1. **File Length**: Maximum 500 lines per file (hard limit), warning at 400 lines
2. **Code Separation**: Keep `browser_use/` (upstream) and `navigator/` (our code) separate
3. **Extend, Don't Modify**: Prefer extending Browser-Use over modifying it
4. **Documentation**: Only 3 canonical docs - never create new doc files
5. **Dependencies**: Always use `uv`, never `pip`
6. **Code Style**: Tabs (not spaces), Python 3.12+ typing, async/await, Pydantic v2
7. **Testing**: Tests in `tests/ci/` with prefix `test_navigator_*`

### ðŸ“ Directory Structure
- `browser_use/` - Embedded Browser-Use library (upstream, don't modify)
- `navigator/` - Our custom code (full control)
- `dev-docs/` - Only 3 canonical documentation files

### ðŸ”§ Common Commands
```bash
uv run pytest tests/ci/              # Run tests
uv run ruff check --fix              # Lint & format
uv run pyright                       # Type check
uv sync                              # Install dependencies
```

---

## âš ï¸ CRITICAL: File Length Rules

### Why These Rules Exist

Large files (>500 lines) cause:
- **Asyncio Errors**: `InvalidStateError`, `Result is not set` (evidence: `workflows_extraction.py` 1,427 lines caused errors)
- **Maintainability Issues**: Hard to understand, debug, test, and review
- **Temporal Workflow Issues**: Increased risk of non-deterministic behavior

### Rules (NO EXCEPTIONS)

1. **Maximum 500 lines** - Hard limit for all production Python files in `navigator/`
2. **Warning at 400 lines** - Start planning split
3. **Test files: 1000 lines max** - Still prefer splitting

### Enforcement

**Before adding code:**
- Check: `wc -l <file_path>`
- If >400 lines: Consider splitting
- If >500 lines: **STOP** - Split immediately
- If would exceed 500: Split first, then add code

**Split strategies:**
- By functionality (group related functions)
- By phase (workflow phases)
- By entity type (storage by entity)
- By protocol/API (server files)
- By action type (dispatchers)

**Maintain backward compatibility:**
- Use `__init__.py` to re-export public APIs
- Update imports gradually
- No breaking changes to public interfaces

**See `dev-docs/FILE_SPLITTING_IMPLEMENTATION_PLAN.md` for detailed split strategies.**

---

## Code Organization

### Core Principle: Separation of Concerns

**Browser-Use (`browser_use/`)**: Embedded upstream library source
- Keep clean and upgradeable
- Don't modify unless absolutely necessary
- Document any modifications

**Our Extensions (`navigator/`)**: Our custom code
- Full control and responsibility
- Extend Browser-Use, don't modify it
- Organize by feature area

### Import Patterns

**âœ… DO:**
```python
from browser_use import BrowserSession
from browser_use.browser.profile import BrowserProfile
```

**âŒ DON'T:**
- Modify Browser-Use code directly
- Mix our code into `browser_use/` directory
- Hack Browser-Use internals

### Extending vs Modifying

**âœ… Extend (Preferred):**
- Create wrapper classes in `navigator/`
- Use Browser-Use public APIs
- Add new functionality via composition

**âš ï¸ Modify (Only When Necessary):**
- Document clearly in CHANGELOG.md
- Use git branches for modifications
- Consider upstream contribution

---

## Documentation Policy

**CRITICAL**: Maintain exactly **3 canonical documentation files**:

1. `dev-docs/QUICK_START.md` - Development setup
2. `dev-docs/BROWSER_AUTOMATION_AGENT.md` - Agent integration
3. `dev-docs/KNOWLEDGE_EXTRACTION.md` - Knowledge pipeline

**Rules:**
- âŒ NEVER create new documentation files (unless explicitly requested)
- âŒ NEVER create README files in subdirectories
- âœ… DO update existing docs when making changes
- âœ… DO focus on schemas/contracts, not verbose code examples

---

## Code Style

Follow Browser-Use conventions (see `CLAUDE.md`):

- **Indentation**: Tabs (not spaces)
- **Type Hints**: Python 3.12+ style (`str | None` not `Optional[str]`)
- **Async**: Use `async`/`await` throughout
- **Pydantic**: Use Pydantic v2 models
- **Logging**: `logger = logging.getLogger(__name__)`

### Import Organization

```python
# Standard library
import asyncio
import logging

# Third-party
from browser_use import BrowserSession

# Our code
from navigator.action.command import ActionCommand
```

---

## Testing

- **Our Tests**: `tests/ci/` with prefix `test_navigator_*`
- **Integration Tests**: Test `navigator/` + `browser_use/` integration
- **Validation**: `navigator/tests/validate_mvp.py`

---

## Browser-Use Upgrade Strategy

### When Upgrading

1. **Backup**: Commit all changes, create backup branch
2. **Review**: Check changelog for breaking changes
3. **Upgrade**: Git merge/rebase or directory replacement
4. **Validate**: Run tests, check imports, verify no regressions
5. **Document**: Update docs, document any required changes

### Tracking Modifications

If modifying Browser-Use code:
- Document in CHANGELOG.md (line, reason, impact)
- Use git branches (`browser-use-modified`)
- Pin version in `pyproject.toml` if upgrade path breaks

**See detailed upgrade process in original rules if needed.**

---

## Git Workflow

### Branching
- `main` - Stable code
- `feature/*` - New features
- `browser-use-upgrade` - Browser-Use upgrades
- `browser-use-modified` - If modifying Browser-Use

### Commit Messages
```
feat(navigator): Add feature
fix(navigator): Fix bug
docs(dev-docs): Update docs
upgrade(browser-use): Upgrade to v0.12.0
```

### Before Committing
1. âœ… Run tests: `uv run pytest tests/ci/`
2. âœ… Run validation: `uv run python navigator/tests/validate_mvp.py`
3. âœ… Lint: `uv run ruff check --fix`
4. âœ… Type check: `uv run pyright`
5. âœ… Verify imports work
6. âœ… No accidental `browser_use/` modifications

---

## Common Patterns

### Wrapper Class
```python
class BrowserSessionManager:
    def __init__(self):
        self.sessions: dict[str, BrowserSession] = {}
    
    async def start_session(self, room_name: str, **kwargs):
        browser_session = BrowserSession(**kwargs)
        await browser_session.start()
        self.sessions[room_name] = browser_session
```

### Event Handler Extension
```python
class ActionDispatcher:
    def __init__(self, browser_session: BrowserSession):
        self.browser_session = browser_session
    
    async def execute_click(self, index: int):
        event = self.browser_session.event_bus.dispatch(
            ClickElementEvent(index=index)
        )
        await event
```

---

## Key Principles

1. âœ… Keep `navigator/` and `browser_use/` separate
2. âœ… Extend, don't modify Browser-Use when possible
3. âœ… Maximum 500 lines per file (hard limit)
4. âœ… Use `uv` for dependency management
5. âœ… Follow Browser-Use code style conventions
6. âœ… Maintain only 3 canonical documentation files
7. âœ… Test after Browser-Use upgrades
8. âœ… Check file length before adding code

---

## Python Best Practices

### General Python Principles

- **Write concise, technical responses** with accurate Python examples
- **Prioritize readability and maintainability** - follow PEP 8 style guidelines
- **Use functional programming** where appropriate; avoid unnecessary classes
- **Prefer vectorized operations** over explicit loops for better performance (when using pandas/numpy)
- **Use descriptive variable names** that reflect the data they contain
- **Follow modern Python typing** - Python 3.12+ style (`str | None` not `Optional[str]`)

### Error Handling and Validation

**Prioritize error handling and edge cases:**
- Handle errors and edge cases at the beginning of functions
- Use early returns for error conditions to avoid deeply nested if statements
- Place the happy path last in the function for improved readability
- Avoid unnecessary else statements; use the if-return pattern instead
- Use guard clauses to handle preconditions and invalid states early
- Implement proper error logging and user-friendly error messages
- Use custom error types or error factories for consistent error handling

**Pattern:**
```python
async def process_data(data: dict[str, Any]) -> Result:
	# Guard clauses first
	if not data:
		raise ValueError("Data cannot be empty")
	
	if "required_field" not in data:
		raise ValueError("Missing required_field")
	
	# Happy path last
	return process_valid_data(data)
```

### Performance Optimization

- **Minimize blocking I/O operations** - use asynchronous operations for all database calls and external API requests
- **Use vectorized operations** in pandas and numpy for improved performance
- **Implement caching** for static and frequently accessed data using tools like Redis or in-memory stores
- **Optimize data serialization** and deserialization with Pydantic
- **Use lazy loading techniques** for large datasets and substantial API responses
- **Profile code** to identify and optimize bottlenecks

### Data Analysis and Manipulation

When working with data analysis tasks:
- Use pandas for data manipulation and analysis
- Prefer method chaining for data transformations when possible
- Use `loc` and `iloc` for explicit data selection
- Utilize `groupby` operations for efficient data aggregation
- Implement data quality checks at the beginning of analysis
- Handle missing data appropriately (imputation, removal, or flagging)

### Async/Await Best Practices

- Use `async def` for asynchronous operations (I/O-bound tasks)
- Use `def` for synchronous operations (CPU-bound tasks)
- Leverage `asyncio` for concurrent operations
- Use connection pooling for database connections
- Implement proper async context managers for resource cleanup

---

## FastAPI Guidelines

When building REST APIs with FastAPI:

### Core Principles
- Use functional, declarative programming; avoid classes where possible
- Use type hints for all function signatures
- Prefer Pydantic v2 models over raw dictionaries for input validation
- Use `async def` for asynchronous operations and `def` for synchronous ones
- Follow the Receive an Object, Return an Object (RORO) pattern

### FastAPI-Specific Guidelines
- Use functional components (plain functions) and Pydantic models for input validation and response schemas
- Use declarative route definitions with clear return type annotations
- Minimize `@app.on_event("startup")` and `@app.on_event("shutdown")`; prefer lifespan context managers
- Use middleware for logging, error monitoring, and performance optimization
- Use `HTTPException` for expected errors and model them as specific HTTP responses
- Use Pydantic's `BaseModel` for consistent input/output validation and response schemas

### Performance
- Minimize blocking I/O operations; use asynchronous operations for all database calls and external API requests
- Implement caching for static and frequently accessed data
- Optimize data serialization and deserialization with Pydantic
- Use lazy loading techniques for large datasets

---

## Django Guidelines

When working with Django (if needed for future features):

### Core Principles
- Use Django's built-in features and tools wherever possible
- Follow Django's coding style guide (PEP 8 compliance)
- Structure project in a modular way using Django apps
- Use descriptive variable and function names; adhere to naming conventions

### Django-Specific Guidelines
- Use Django's class-based views (CBVs) for more complex views; prefer function-based views (FBVs) for simpler logic
- Leverage Django's ORM for database interactions; avoid raw SQL queries unless necessary
- Use Django's built-in user model and authentication framework
- Utilize Django's form and model form classes for form handling and validation
- Follow the MVT (Model-View-Template) pattern strictly
- Use middleware judiciously to handle cross-cutting concerns

### Performance Optimization
- Optimize query performance using Django ORM's `select_related` and `prefetch_related`
- Use Django's cache framework with backend support (e.g., Redis or Memcached)
- Implement database indexing and query optimization techniques
- Use asynchronous views and background tasks (via Celery) for I/O-bound operations

---

## Flask Guidelines

When working with Flask (if needed for future features):

### Core Principles
- Use functional, declarative programming; avoid classes where possible except for Flask views
- Use Flask application factories for better modularity and testing
- Organize routes using Flask Blueprints for better code organization

### Flask-Specific Guidelines
- Use Flask-RESTful for building RESTful APIs with class-based views
- Implement custom error handlers for different types of exceptions
- Use Flask's `before_request`, `after_request`, and `teardown_request` decorators for request lifecycle management
- Utilize Flask extensions for common functionalities (e.g., Flask-SQLAlchemy, Flask-Migrate)
- Use Flask's config object for managing different configurations
- Implement proper logging using Flask's `app.logger`

---

## Package Management with `uv`

**âœ… Use `uv` exclusively** (already enforced in project rules)

### Managing Dependencies

Always use these commands:
```bash
# Add or upgrade dependencies
uv add <package>

# Remove dependencies
uv remove <package>

# Reinstall all dependencies from lock file
uv sync
```

### Running Scripts

```bash
# Run script with proper dependencies
uv run script.py
```

### Inline Script Metadata

You can edit inline-metadata manually:
```python
# /// script
# requires-python = ">=3.12"
# dependencies = [
#     "torch",
#     "numpy",
# ]
# ///
print("some python code")
```

Or using uv CLI:
```bash
# Add or upgrade script dependencies
uv add package-name --script script.py

# Remove script dependencies
uv remove package-name --script script.py

# Reinstall all script dependencies from lock file
uv sync --script script.py
```

---

## Web Scraping Best Practices

When implementing web scraping functionality:

### General Principles
- Use requests for simple HTTP GET/POST requests to static websites
- Parse HTML content with BeautifulSoup for efficient data extraction
- Handle JavaScript-heavy websites with selenium or headless browsers
- Respect website terms of service and use proper request headers (e.g., User-Agent)
- Implement rate limiting and random delays to avoid triggering anti-bot measures

### Error Handling
- Implement robust error handling for common issues:
  - Connection timeouts (`requests.Timeout`)
  - Parsing errors (`BeautifulSoup.FeatureNotFound`)
  - Dynamic content issues (Selenium element not found)
- Retry failed requests with exponential backoff to prevent overloading servers
- Log errors and maintain detailed error messages for debugging

### Performance
- Optimize data parsing by targeting specific HTML elements (e.g., id, class, or XPath)
- Use asyncio or concurrent.futures for concurrent scraping
- Implement caching for repeated requests using libraries like requests-cache
- Profile and optimize code using tools like cProfile or line_profiler

---

## Testing Best Practices

### General Testing Principles
- Write unit tests using pytest
- Use pytest fixtures for test setup and teardown
- Implement test fixtures for database and application setup
- Test edge cases and error conditions
- Use mocking judiciously - prefer real objects when possible (as per project rules)

### Test Organization
- Keep tests focused and modular
- Use descriptive test names that explain what is being tested
- Group related tests in classes or modules
- Use parametrized tests for testing multiple scenarios

### Async Testing
- Use `pytest-asyncio` for async test functions
- Modern pytest-asyncio: No `@pytest.mark.asyncio` decorator needed on async test functions
- Use `loop = asyncio.get_event_loop()` inside tests that need it
- Fixture functions (even async ones) only need `@pytest.fixture` decorator

---

## Deep Learning / ML Guidelines

When working with machine learning or deep learning:

### PyTorch Best Practices
- Use PyTorch as the primary framework for deep learning tasks
- Implement custom `nn.Module` classes for model architectures
- Utilize PyTorch's autograd for automatic differentiation
- Implement proper weight initialization and normalization techniques
- Use appropriate loss functions and optimization algorithms

### Model Training
- Implement efficient data loading using PyTorch's DataLoader
- Use proper train/validation/test splits and cross-validation when appropriate
- Implement early stopping and learning rate scheduling
- Use appropriate evaluation metrics for the specific task
- Implement gradient clipping and proper handling of NaN/Inf values

### Performance
- Utilize DataParallel or DistributedDataParallel for multi-GPU training
- Implement gradient accumulation for large batch sizes
- Use mixed precision training with `torch.cuda.amp` when appropriate
- Profile code to identify and optimize bottlenecks

---

## Security Best Practices

### Input Validation
- Sanitize all external inputs
- Never invoke shell commands with unsanitized strings
- Use secure defaults (e.g., TLSv1.2+, strong cipher suites)
- Validate data types and ranges to ensure data integrity

### Secrets Management
- Ensure secrets (API keys, credentials) are loaded from secure stores or environment variables
- Never hardcode credentials in source code
- Use environment variables or secure configuration management

### API Security
- Implement rate limiting and back-off for network operations
- Use proper authentication and authorization mechanisms
- Apply security headers (e.g., CORS, CSP)
- Implement content validation using security tools

---

*Last Updated: 2025*
*Version: 2.1.0*
